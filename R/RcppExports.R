# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @export
deLR <- function(X, y, adjacency_matrix, B_init, betaT, T_inner = 20L, tau_penalty_factor = 1 / 6.0, nlambda = 100L, lambda_factor = 1e-4, lambda_max = 1.0, quiet = TRUE, epsilon = 1e-6) {
    .Call(`_decentralized1bit_deLR`, X, y, adjacency_matrix, B_init, betaT, T_inner, tau_penalty_factor, nlambda, lambda_factor, lambda_max, quiet, epsilon)
}

#' @export
deLRwsupp <- function(X, y, adjacency_matrix, B_init, betaT, T_inner = 20L, tau_penalty_factor = 1 / 6.0, nlambda = 100L, lambda_factor = 1e-4, lambda_max = 1.0, quiet = TRUE, epsilon = 1e-6) {
    .Call(`_decentralized1bit_deLRwsupp`, X, y, adjacency_matrix, B_init, betaT, T_inner, tau_penalty_factor, nlambda, lambda_factor, lambda_max, quiet, epsilon)
}

#' @export
deSubGD_LS_single <- function(X, y, adjacency_matrix, B_init, betaT, T = 20L, a = 3.5, b = 0.51, lambda = 1e-2, eps = 1e-4, quiet = TRUE) {
    .Call(`_decentralized1bit_deSubGD_LS_single`, X, y, adjacency_matrix, B_init, betaT, T, a, b, lambda, eps, quiet)
}

#' @export
deSubGD_LS <- function(X, y, adjacency_matrix, B_init, betaT, T = 20L, a = 3.5, b = 0.51, K = 19L, nlambda = 100L, lambda_factor = 1e-4, lambda_max = 1, eps = 1e-2, quiet = TRUE) {
    .Call(`_decentralized1bit_deSubGD_LS`, X, y, adjacency_matrix, B_init, betaT, T, a, b, K, nlambda, lambda_factor, lambda_max, eps, quiet)
}

#' RcppArmadillo implementation of the R pmax()
#' function
#'
#' @title RcppArmadillo implemenation of the r pmax function
#' @param x the (aramdillo) vector
#' @param bound the (double) bound
#'
pmax_arma <- function(x, bound) {
    .Call(`_decentralized1bit_pmax_arma`, x, bound)
}

#' Kernel fitting
#'
#' Conduct the Nadaraya-Watson kernel regression to estimate the density of the
#' errs.
#'
#' @param E A n-by-K residual matrix, where n is sample size and K is the
#' quantile levels
#' @param h A n-by-K bandwidth
#'
#' @return
#' A K-by-1 density estimate vector.
#' @examples
#' set.seed(1)
#' library(pracma)
#' p <- 600
#' n <- 100
#' case <- "cauchy"
#' betaT <- rep(0, p)
#' betaT[1] <- 3
#' betaT[2] <- 1.5
#' betaT[5] <- 2
#' s <- length(which(abs(betaT)>0))
#' rho <- 0.5
#' data <- gen_data(n, p, betaT, case, rho)
#' x <- data$x
#' y <- data$y
#' data_val <- gen_data(n, p, betaT, case, rho)
#' x_val <- data_val$x
#' y_val <- data_val$y
#' K <- 19
#' tau <- 0.05 * (1:K)
#' m <- qraenet(x = x, y = y, tau = 0.5, standardize = FALSE,
#' intercept = FALSE, lambda2 = 0, sigma = 1, method = "padmm")
#' nlambda <- length(m$lambda)
#' validation_err <- rep(NA, nlambda)
#' for(ivalidation_err in 1:nlambda) {
#'   validation_err[ivalidation_err] <-
#'     sum((y_val - x_val%*%m$beta[,ivalidation_err])^2)
#' }
#' beta_init <-  matrix(as.numeric(m$beta[,which.min(validation_err)]))
#' alpha_init <- quantile(y - x%*%beta_init, tau)
#' E <- repmat(y - x%*%beta_init, 1, K) - repmat(alpha_init, n, 1);
#' h <- rep(sqrt(s*log(n)/n), K)
#' fh <- kernel(E, h)
#' @export
kernel <- function(E, h) {
    .Call(`_decentralized1bit_kernel`, E, h)
}

#' @title Mode of a given vector
#' @description
#' Find the mode of a given numerical vector.
#' @name mod
#' @param v A vector of real numbers
#' @return the mode of the vector
#' @examples
#' v <- c(rep(1,10),rep(2,9))
#' mod(v)
#' @export
mod <- function(v) {
    .Call(`_decentralized1bit_mod`, v)
}

#' @export
quantile_lossCPP <- function(x, tau) {
    .Call(`_decentralized1bit_quantile_lossCPP`, x, tau)
}

#' @export
cqr_loss_cpp <- function(X, y, beta, alpha, tau) {
    .Call(`_decentralized1bit_cqr_loss_cpp`, X, y, beta, alpha, tau)
}

#' @export
calN_j_cpp <- function(n, j) {
    .Call(`_decentralized1bit_calN_j_cpp`, n, j)
}

